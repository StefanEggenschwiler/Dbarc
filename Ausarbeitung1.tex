\documentclass[10pt]{article}

%Math
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{ulem}
\usepackage{stmaryrd} %f\UTF{00FC}r Blitz!

%PageStyle
\usepackage[ngerman]{babel} % deutsche Silbentrennung
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr, graphicx}
\usepackage[scaled=0.92]{helvet}
\usepackage{enumitem}
\usepackage{parskip}
\usepackage[a4paper,top=2cm]{geometry}
\usepackage{framed}
\setlength{\textwidth}{17cm}
\setlength{\oddsidemargin}{-0.5cm}

% Shortcommands
\newcommand{\Bold}[1]{\textbf{#1}} %Boldface
\newcommand{\Kursiv}[1]{\textit{#1}} %Italic
\newcommand{\T}[1]{\text{#1}} %Textmode
\newcommand{\Nicht}[1]{\T{\sout{$ #1 $}}} %Streicht Shit durch

%Arrows
\newcommand{\lra}{\leftrightarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\lral}{\longleftrightarrow}
\newcommand{\ral}{\longrightarrow}
\newcommand{\lal}{\longleftarrow}
\newcommand{\Lra}{\Leftrightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\La}{\Leftarrow}
\newcommand{\Lral}{\Longleftrightarrow}
\newcommand{\Ral}{\Longrightarrow}
\newcommand{\Lal}{\Longleftarrow}

% Code listenings
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{white}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white,font=bf}


\lstdefinestyle{sqlNoTitle}{
   language=SQL,
   basicstyle=\footnotesize\ttfamily, % Standardschrift
   backgroundcolor=\color[RGB]{255,255,0}, % Hintergrundfarbe
   numbers=left, % Ort der Zeilennummern
   numberstyle=\tiny, % Stil der Zeilennummern
   stepnumber=1, % Abstand zwischen den Zeilennummern
   numbersep=5pt, % Abstand der Nummern zum Text
   tabsize=2, % Groesse von Tabs
   extendedchars=true, %
   breaklines=true, % Zeilen werden Umgebrochen
   frame=trbl, % Rahmen
   stringstyle=\color[RGB]{42,0,255} \ttfamily, % Farbe der String
   keywordstyle=\color[RGB]{127,0,85} \bfseries, % Farbe der Keywords
   commentstyle=\color[RGB]{63,127,95} \ttfamily, % Farbe des Kommentars
   showspaces=false, % Leerzeichen anzeigen ?
   showtabs=false, % Tabs anzeigen ?
   xleftmargin=17pt,
   framexleftmargin=17pt,
   framexrightmargin=5pt,
   framexbottommargin=5pt,
   framextopmargin=5pt,
   showstringspaces=false, % Leerzeichen in Strings anzeigen ?
}


\lstdefinestyle{sql}{
   style=sqlNoTitle,
   % title=SQL-Query
}

\lstdefinestyle{queryexecutionplan}{
  basicstyle=\scriptsize\ttfamily, % Standardschrift
  backgroundcolor=\color[RGB]{238,233,233}, % Hintergrundfarbe
  frame=trbl, % Rahmen
  %title=Ausführungsplan
}

%Config
\renewcommand{\headrulewidth}{0pt}
\setlength{\headheight}{15.2pt}

%Metadata
\fancyfoot[C]{}
\title{
\vspace{4cm}
\huge{Datenbank Architektur für Fortgeschrittene}\\
\vspace{0.2cm}
\Large{Ausarbeitung 1: Anfrageverarbeitung}\\
}
\author{Daniel Gürber \cr Stefan Eggenschwiler}
\date{02.05.2013}

% hier beginnt das Dokument
\begin{document}

% Titelbild
\maketitle
\thispagestyle{fancy}

\newpage

% Inhaltsverzeichnis
\pagenumbering{Roman}
\tableofcontents	


\newpage
\setcounter{page}{1}
\pagenumbering{arabic}

% Inhalt Start

\section{Vorbereitung}
\subsection{Einleitung}
Diese Ausarbeitung behandelt die Übung „SQL Tuning“. Sie wird Schritt für Schritt gelöst. Gezeigt werden das SQL-Statement und den dazugehörigen Ausführungsplan, der von der Oracle Datenbank generiert wird. Bei nennenswerten Erkenntnissen werden diese unterhalb des Ausführungsplan in einer kurzen Reflexion behandelt. Die Nummerierung im Dokument entspricht dabei der Nummern des Übungsblattes.
Um die Übung auszuführen haben wir folgende Verbindungsdaten verwendet: \newline \newline
Connection Name hades11gdbarc03 \newline
Username dbarc03 \newline
Password <YouKnowIt> \newline
Role default \newline
Connection Type Basic \newline
Hostname hades.imvs.technik.fhnw.ch \newline
Port 1521 \newline
SID <kein Eintrag> \newline
Service Name hades11g.hades.fhnw.ch

\subsection{Einrichten Datenbasis}
\begin{lstlisting}[style=sql]
CREATE TABLE regions
AS SELECT *
  FROM dbarc00.regions;
  
CREATE TABLE nations
AS SELECT *
  FROM dbarc00.nations;

CREATE TABLE parts
AS SELECT *
  FROM dbarc00.parts;
  
CREATE TABLE customers
AS SELECT *
  FROM dbarc00.customers;

CREATE TABLE suppliers
AS SELECT *
  FROM dbarc00.suppliers;

CREATE TABLE orders
AS SELECT *
  FROM dbarc00.orders;

CREATE TABLE partsupps
AS SELECT *
  FROM dbarc00.partsupps;

CREATE TABLE lineitems
AS SELECT *
  FROM dbarc00.lineitems;
\end{lstlisting}
\newpage
\section{Statistiken erheben}
\begin{lstlisting}[style=sql]
BEGIN
	DBMS_STATS.GATHER_TABLE_STATS('dbarc00','parts');
END;
\end{lstlisting}
{\normalsize
\begin{tabular}{|l|l|l|l|l|}
\hline
Tabelle & Anzahl Zeilen & Grösse in Bytes & Anzahl Blöcke & Anzahl Extents \\
\hline
\hline
CUSTOMERS & 150000 & 23850000 & 3494 & 43 \\
\hline
LINEITEMS & 6001215 & 750151875 & 109217 & 186 \\
\hline
NATIONS & 25 & 2675 & 4 & 1 \\
\hline
ORDER & 1500000 & 166500000 & 24284 &  95 \\
\hline
PARTS & 200000 & 26400000 & 3859 & 46 \\
\hline
PARTSUPPS & 800000 & 114400000 & 16650 & 88 \\
\hline
REGIONS & 5 & 480 & 4 & 1 \\
\hline
\end{tabular}
}


\section{Ausführungsplan}
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM parts;
\end{lstlisting}
\begin{lstlisting}[style=sql]
SELECT plan_table_output
FROM TABLE(DBMS_XPLAN.DISPLAY('plan_table',null,'serial'));
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |   200K|    25M|  1051   (1)| 00:00:13 |
|   1 |  TABLE ACCESS FULL| PARTS |   200K|    25M|  1051   (1)| 00:00:13 |
---------------------------------------------------------------------------
\end{lstlisting}
\textbf{Reflexion} \newline
Da weder ein Index, noch ein Filterkriterium gesetzt sind, wird die gesamte Tabelle ausgelesen und zurückgegeben.

\section{Versuche ohne Index}
\subsection{Projektion}
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM ORDERS;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |  1500K|   158M|  6610   (1)| 00:01:20 |
|   1 |  TABLE ACCESS FULL| ORDERS |  1500K|   158M|  6610   (1)| 00:01:20 |
----------------------------------------------------------------------------
\end{lstlisting}
\textbf{Reflexion} \newline
Da weder ein Index, noch ein Filterkriterium gesetzt sind, wird die gesamte Tabelle ausgelesen und zurückgegeben.
\newpage
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT o_clerk
FROM ORDERS;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |  1500K|    22M|  6607   (1)| 00:01:20 |
|   1 |  TABLE ACCESS FULL| ORDERS |  1500K|    22M|  6607   (1)| 00:01:20 |
----------------------------------------------------------------------------
\end{lstlisting}
\textbf{Reflexion} \newline
Da weder ein Index, noch ein Filterkriterium gesetzt sind, wird die gesamte Tabelle ausgelesen, da aber nur die o\_clerk Spalte ausgelesen wird, sinkt die Größe von 158 MB auf 22 MB.

\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT DISTINCT o_clerk
FROM ORDERS;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
-----------------------------------------------------------------------------
| Id  | Operation          | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |        |  1000 | 16000 |  6676   (2)| 00:01:21 |
|   1 |  HASH UNIQUE       |        |  1000 | 16000 |  6676   (2)| 00:01:21 |
|   2 |   TABLE ACCESS FULL| ORDERS |  1500K|    22M|  6607   (1)| 00:01:20 |
-----------------------------------------------------------------------------
\end{lstlisting}
\textbf{Reflexion} \newline
Da weder ein Index, noch ein Filterkriterium gesetzt sind, wird die gesamte Tabelle ausgelesen. Durch das Schlüsselwort DISTINCT wird ein HASH UNIQUE ausgelöst, wodurch die Kosten auf 6676 steigen, die Grösse aber auf 16000 Bytes sinkt.
\subsection{Selektion}
\textbf{Exact Point Query}
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM orders
WHERE o_orderkey=44444;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |     1 |   111 |  6602   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |     1 |   111 |  6602   (1)| 00:01:20 |
----------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"=44444)
\end{lstlisting}
\textbf{Reflexion} \newline
Da kein Index vorhanden ist, wird die ganze Tabelle ausgelesen und auf o\_orderkey gefiltert.

\newpage
\textbf{Partial Point Query}
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM orders
WHERE o_orderkey=44444 OR o_clerk='Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |  1501 |   162K|  6629   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |  1501 |   162K|  6629   (1)| 00:01:20 |
----------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_CLERK"='Clerk#000000286' OR "O_ORDERKEY"=44444)
\end{lstlisting}
\textbf{Reflexion} \newline
Da kein Index vorhanden ist, wird die ganze Tabelle ausgelesen und auf o\_orderkey und o\_clerk gefiltert, die zusätzliche Bedingung erhöht die Kosten von 6602 auf 6629.

\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM orders
WHERE o_orderkey=44444 AND o_clerk='Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |     1 |   111 |  6611   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |     1 |   111 |  6611   (1)| 00:01:20 |
----------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"=44444 AND "O_CLERK"='Clerk#000000286')
\end{lstlisting}
\textbf{Reflexion} \newline
Da kein Index vorhanden ist, wird die ganze Tabelle ausgelesen und auf o\_orderkey und o\_clerk gefiltert, die AND Bedingung senkt von die Kosten von 6629 auf 6611 verglichen mit der OR Bedingung.

\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR 
SELECT *
FROM orders
WHERE o_orderkey*2=44444 AND o_clerk='Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |    15 |  1665 |  6615   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |    15 |  1665 |  6615   (1)| 00:01:20 |
----------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"*2=44444 AND "O_CLERK"='Clerk#000000286')
\end{lstlisting}
\textbf{Reflexion} \newline
Da kein Index vorhanden ist, wird die ganze Tabelle ausgelesen und auf o\_orderkey und o\_clerk gefiltert, die zusätzliche Multiplikation erhöht die Kosten nur um 4.
\newpage
\textbf{Range Query}
\begin{lstlisting}[style=sqlNoTitle]
EXPLAIN PLAN FOR
SELECT *
FROM orders
WHERE o_orderkey BETWEEN 111111 AND 222222
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        | 27780 |  3011K|  6603   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS | 27780 |  3011K|  6603   (1)| 00:01:20 |
----------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"<=222222 AND "O_ORDERKEY">=111111)
\end{lstlisting}
\textbf{Reflexion} \newline
Da kein Index vorhanden ist, wird die ganze Tabelle ausgelesen und auf o\_orderkey gefiltert, die Range Query ist nur um 1 teurer als die Abfrage auf den einzelnen Wert.
Die Intervallgrösse spielt in diesem Beispiel, abgesehen von der höheren bzw. tieferen Anzahl Bytes keine Rolle.

\textbf{Partial Range Query}
\begin{lstlisting}[style=sqlNoTitle]
EXPLAIN PLAN FOR
SELECT *
FROM orders
WHERE o_orderkey BETWEEN 44444 AND 55555
AND   o_clerk BETWEEN 'Clerk#000000130' AND 'Clerk#000000139'
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |     6 |   666 |  6611   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |     6 |   666 |  6611   (1)| 00:01:20 |
----------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"<=55555 AND "O_CLERK"<='Clerk#000000139' AND 
              "O_ORDERKEY">=44444 AND "O_CLERK">='Clerk#000000130')
\end{lstlisting}
\textbf{Reflexion} \newline
Da kein Index vorhanden ist, wird die ganze Tabelle ausgelesen und auf o\_orderkey und o\_clerk gefiltert, die Range Query ist nur um 8 teurer als die letzte Abfrage.

\subsection{Join}
\begin{lstlisting}[style=sqlNoTitle]
EXPLAIN PLAN FOR
SELECT *
FROM orders, customers
WHERE o_custkey = c_custkey
AND   o_orderkey < 100;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
--------------------------------------------------------------------------------
| Id  | Operation          | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |           |    25 |  6750 |  7555   (1)| 00:01:31 |
|*  1 |  HASH JOIN         |           |    25 |  6750 |  7555   (1)| 00:01:31 |
|*  2 |   TABLE ACCESS FULL| ORDERS    |    25 |  2775 |  6602   (1)| 00:01:20 |
|   3 |   TABLE ACCESS FULL| CUSTOMERS |   150K|    22M|   951   (1)| 00:00:12 |
--------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("O_CUSTKEY"="C_CUSTKEY")
   2 - filter("O_ORDERKEY"<100)
\end{lstlisting}
\textbf{Reflexion} \newline
Da kein Index vorhanden ist, werden beide Tabellen voll geladen. Die orders Tabelle wird gefiltert und mit Hilfe von custkey word ein HASH JOIN ausgeführt.
Die Formulierung mit INNER JOIN spielt

\section{Versuch mit Index}
\begin{lstlisting}[style=sql]
CREATE INDEX o_orderkey_ix ON orders(o_orderkey);
\end{lstlisting}
\begin{lstlisting}[style=sql]
CREATE INDEX o_clerk_ix ON orders(o_clerk);
\end{lstlisting}
{\normalsize
\begin{tabular}{|l|l|l|}
\hline
 Index Name & Index Grösse & Tabellengrösse in Bytes \\
\hline
\hline
o\_orderkey\_ix & 60817408 & 166500000 \\
\hline
o\_clerik\_ix & 96468992	 & 166500000 \\
\hline
\end{tabular}
}

\subsection{Projektion}
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT DISTINCT o_clerk
FROM ORDERS;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
------------------------------------------------------------------------------------
| Id  | Operation             | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |            |  1000 | 16000 |  1615   (5)| 00:00:20 |
|   1 |  HASH UNIQUE          |            |  1000 | 16000 |  1615   (5)| 00:00:20 |
|   2 |   INDEX FAST FULL SCAN| O_CLERK_IX |  1500K|    22M|  1546   (1)| 00:00:19 |
------------------------------------------------------------------------------------
\end{lstlisting}
\textbf{Reflexion} \newline
Die Verwendung des Index senkt die Kosten dieser abfrage von 6676 auf 1615 (Faktor 4.1).

\subsection{Selektion}
Exact Point Query
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM ORDERS
WHERE o_orderkey=44444
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
---------------------------------------------------------------------------------------------
| Id  | Operation                   | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |               |     1 |   111 |     4   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| ORDERS        |     1 |   111 |     4   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | O_ORDERKEY_IX |     1 |       |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("O_ORDERKEY"=44444)
\end{lstlisting}

\textbf{Reflexion} \newline
Die Verwendung des Index senkt die Kosten dieser abfrage von 6602 auf 4 (Faktor 1650).
\newpage
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT /*+ FULL(orders) */ *
FROM ORDERS
WHERE o_orderkey=44444
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |     1 |   111 |  6602   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |     1 |   111 |  6602   (1)| 00:01:20 |
----------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"=44444)
\end{lstlisting}
\textbf{Reflexion} \newline
Wenn ein TABLE ACCESS FULL erzwungen wird, entsprechen die Kosten wieder denen ohne Index.

Partial Point Query
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM orders
WHERE o_orderkey=44444 OR o_clerk='Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
--------------------------------------------------------------------------------------------------
| Id  | Operation                        | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |               |  1501 |   162K|   336   (0)| 00:00:05 |
|   1 |  TABLE ACCESS BY INDEX ROWID     | ORDERS        |  1501 |   162K|   336   (0)| 00:00:05 |
|   2 |   BITMAP CONVERSION TO ROWIDS    |               |       |       |            |          |
|   3 |    BITMAP OR                     |               |       |       |            |          |
|   4 |     BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|*  5 |      INDEX RANGE SCAN            | O_CLERK_IX    |       |       |     8   (0)| 00:00:01 |
|   6 |     BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|*  7 |      INDEX RANGE SCAN            | O_ORDERKEY_IX |       |       |     3   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   5 - access("O_CLERK"='Clerk#000000286')
   7 - access("O_ORDERKEY"=44444)
\end{lstlisting}
\textbf{Reflexion} \newline
Die Verwendung der Indexes senkt die Kosten von 6611 auf 336 (Faktor 19.7) und führt zu BITMAP Operationen.

\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM orders
WHERE o_orderkey=44444 AND o_clerk='Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
---------------------------------------------------------------------------------------------
| Id  | Operation                   | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |               |     1 |   111 |     4   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS BY INDEX ROWID| ORDERS        |     1 |   111 |     4   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | O_ORDERKEY_IX |     1 |       |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_CLERK"='Clerk#000000286')
   2 - access("O_ORDERKEY"=44444)
\end{lstlisting}
\textbf{Reflexion} \newline
Die Verwendung des Index senkt die Kosten dieser Abfrage von 6611 auf 4 (Faktor 1652.8) und ist somit stärker optimiert als die OR Abfrage.
\newpage
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM orders
WHERE o_orderkey*2=44444 AND o_clerk='Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
------------------------------------------------------------------------------------------
| Id  | Operation                   | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |            |    15 |  1665 |  1464   (1)| 00:00:18 |
|*  1 |  TABLE ACCESS BY INDEX ROWID| ORDERS     |    15 |  1665 |  1464   (1)| 00:00:18 |
|*  2 |   INDEX RANGE SCAN          | O_CLERK_IX |  1500 |       |     8   (0)| 00:00:01 |
------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"*2=44444)
   2 - access("O_CLERK"='Clerk#000000286')
\end{lstlisting}
\textbf{Reflexion} \newline
Die Verwendung des Index senkt die Kosten dieser Abfrage von 6615 auf 1464 (Faktor 4.5) sie ist aber, wegen der Multiplikation, um den Faktor 366 langsamer als die vorherige AND Abfrage, im Gegensatz zum Faktor 1.0006 ohne Index.

Range Query
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM orders
WHERE o_orderkey BETWEEN 111111 AND 222222
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
---------------------------------------------------------------------------------------------
| Id  | Operation                   | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |               | 27780 |  3011K|   932   (1)| 00:00:12 |
|   1 |  TABLE ACCESS BY INDEX ROWID| ORDERS        | 27780 |  3011K|   932   (1)| 00:00:12 |
|*  2 |   INDEX RANGE SCAN          | O_ORDERKEY_IX | 27780 |       |    68   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("O_ORDERKEY">=111111 AND "O_ORDERKEY"<=222222)
\end{lstlisting}
\textbf{Reflexion} \newline
Die Verwendung des Index senkt die Kosten dieser Abfrage von 6603 auf 932 (Faktor 7.1). Wird der Intervall genug gross gewählt, z.B. 222222222, wird wieder ein TABLE ACCESS FULL ausgeführt, da der aufwand für die Index Berechnungen grösser wäre.

Partial Range Query
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM orders
WHERE o_orderkey BETWEEN 44444 AND 55555
AND   o_clerk BETWEEN 'Clerk#000000130' AND 'Clerk#000000139'
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
--------------------------------------------------------------------------------------------------
| Id  | Operation                        | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |               |     6 |   666 |    27  (12)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID     | ORDERS        |     6 |   666 |    27  (12)| 00:00:01 |
|   2 |   BITMAP CONVERSION TO ROWIDS    |               |       |       |            |          |
|   3 |    BITMAP AND                    |               |       |       |            |          |
|   4 |     BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|   5 |      SORT ORDER BY               |               |       |       |            |          |
|*  6 |       INDEX RANGE SCAN           | O_ORDERKEY_IX |  2780 |       |     9   (0)| 00:00:01 |
|   7 |     BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|   8 |      SORT ORDER BY               |               |       |       |            |          |
|*  9 |       INDEX RANGE SCAN           | O_CLERK_IX    |  2780 |       |    14   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   6 - access("O_ORDERKEY">=44444 AND "O_ORDERKEY"<=55555)
   9 - access("O_CLERK">='Clerk#000000130' AND "O_CLERK"<='Clerk#000000139')
\end{lstlisting}
\textbf{Reflexion} \newline
Die Verwendung des Index senkt die Kosten dieser Abfrage von 6611 auf 27 (Faktor 244.9), die Verwendung von 2 Filterkriterien führt wieder zu BITMAP Operationen.

\subsection{Join}
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM orders, customers
WHERE o_custkey = c_custkey;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------------------
| Id  | Operation          | Name      | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |           |  1500K|   386M|       | 17514   (1)| 00:03:31 |
|*  1 |  HASH JOIN         |           |  1500K|   386M|    24M| 17514   (1)| 00:03:31 |
|   2 |   TABLE ACCESS FULL| CUSTOMERS |   150K|    22M|       |   951   (1)| 00:00:12 |
|   3 |   TABLE ACCESS FULL| ORDERS    |  1500K|   158M|       |  6610   (1)| 00:01:20 |
----------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("O_CUSTKEY"="C_CUSTKEY")
\end{lstlisting}
\textbf{Reflexion} \newline
In diesem Statement wird auf beide Tabellen TABLE ACCESS FULL ausgeführt, die gesetzten Indexes haben keinen Einfluss auf den Ausführungsplan.

\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM orders, customers
WHERE o_custkey = c_custkey
AND   o_orderkey < 100;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------------------------
| Id  | Operation                    | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |               |    25 |  6750 |   957   (1)| 00:00:12 |
|*  1 |  HASH JOIN                   |               |    25 |  6750 |   957   (1)| 00:00:12 |
|   2 |   TABLE ACCESS BY INDEX ROWID| ORDERS        |    25 |  2775 |     4   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN          | O_ORDERKEY_IX |    25 |       |     3   (0)| 00:00:01 |
|   4 |   TABLE ACCESS FULL          | CUSTOMERS     |   150K|    22M|   951   (1)| 00:00:12 |
----------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("O_CUSTKEY"="C_CUSTKEY")
   3 - access("O_ORDERKEY"<100)
\end{lstlisting}
\textbf{Reflexion} \newline
Die Verwendung des Index senkt die Kosten dieser Abfrage von 7555 auf 957 (Faktor 7.9).
\newpage
\begin{lstlisting}[style=sql]
CREATE INDEX c_custkey_ix ON customers(c_custkey);
\end{lstlisting}
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM orders, customers
WHERE o_custkey = c_custkey;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------------------
| Id  | Operation          | Name      | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |           |  1500K|   386M|       | 17514   (1)| 00:03:31 |
|*  1 |  HASH JOIN         |           |  1500K|   386M|    24M| 17514   (1)| 00:03:31 |
|   2 |   TABLE ACCESS FULL| CUSTOMERS |   150K|    22M|       |   951   (1)| 00:00:12 |
|   3 |   TABLE ACCESS FULL| ORDERS    |  1500K|   158M|       |  6610   (1)| 00:01:20 |
----------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("O_CUSTKEY"="C_CUSTKEY")
\end{lstlisting}
\textbf{Reflexion} \newline
Auf diese Abfrage hat das setzen des Indexes keinen Einfluss.

Erzwingen eines Nested Loop Joins:
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT /*+ USE_NL (o c) */ *
FROM orders o, customers c
WHERE o_custkey = c_custkey;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
---------------------------------------------------------------------------------------------
| Id  | Operation                    | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |              |  1500K|   386M|  3007K  (1)| 10:01:34 |
|   1 |  NESTED LOOPS                |              |       |       |            |          |
|   2 |   NESTED LOOPS               |              |  1500K|   386M|  3007K  (1)| 10:01:34 |
|   3 |    TABLE ACCESS FULL         | ORDERS       |  1500K|   158M|  6610   (1)| 00:01:20 |
|*  4 |    INDEX RANGE SCAN          | C_CUSTKEY_IX |     1 |       |     1   (0)| 00:00:01 |
|   5 |   TABLE ACCESS BY INDEX ROWID| CUSTOMERS    |     1 |   159 |     2   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   4 - access("O_CUSTKEY"="C_CUSTKEY")
\end{lstlisting}
\textbf{Reflexion} \newline
Das Erzwingen des NESTED LOOPS führt zwar zur Verwendung des Index, steigert aber die Kosten auf von 17514 auf 3007K.

Erzwingen eines Nicht-Hash Joins:
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT /*+ NO_USE_HASH (o c) */ *
FROM orders o, customers c
WHERE o_custkey = c_custkey;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
-----------------------------------------------------------------------------------------
| Id  | Operation           | Name      | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
-----------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT    |           |  1500K|   386M|       | 50568   (1)| 00:10:07 |
|   1 |  MERGE JOIN         |           |  1500K|   386M|       | 50568   (1)| 00:10:07 |
|   2 |   SORT JOIN         |           |   150K|    22M|    52M|  6202   (1)| 00:01:15 |
|   3 |    TABLE ACCESS FULL| CUSTOMERS |   150K|    22M|       |   951   (1)| 00:00:12 |
|*  4 |   SORT JOIN         |           |  1500K|   158M|   390M| 44366   (1)| 00:08:53 |
|   5 |    TABLE ACCESS FULL| ORDERS    |  1500K|   158M|       |  6610   (1)| 00:01:20 |
-----------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   4 - access("O_CUSTKEY"="C_CUSTKEY")
       filter("O_CUSTKEY"="C_CUSTKEY")
\end{lstlisting}
\textbf{Reflexion} \newline
Das Erzwingen des NESTED LOOPS führt nicht zur Verwendung des Index, und steigert aber die Kosten auf von 17514 auf 50568.

\section{Quiz}
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT count(*)
FROM parts, partsupps, lineitems
WHERE p_partkey=ps_partkey
AND ps_partkey=l_partkey
AND ps_suppkey=l_suppkey
AND ((ps_partkey = 5 AND p_type = 'MEDIUM ANODIZED BRASS')
OR (ps_partkey = 5 AND p_type = 'MEDIUM BRUSHED COPPER'));
\end{lstlisting}
Ausgangslage:
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------------
| Id  | Operation            | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |           |     1 |    45 | 35577   (2)| 00:07:07 |
|   1 |  SORT AGGREGATE      |           |     1 |    45 |            |          |
|*  2 |   HASH JOIN          |           |     4 |   180 | 35577   (2)| 00:07:07 |
|*  3 |    HASH JOIN         |           |     4 |   144 |  5872   (6)| 00:01:11 |
|*  4 |     TABLE ACCESS FULL| PARTSUPPS |     4 |    36 |  4525   (1)| 00:00:55 |
|*  5 |     TABLE ACCESS FULL| PARTS     |  2667 | 72009 |  1052   (1)| 00:00:13 |
|   6 |    TABLE ACCESS FULL | LINEITEMS |  6001K|    51M| 29675   (1)| 00:05:57 |
----------------------------------------------------------------------------------
Predicate Information (identified by operation id):
--------------------------------------------------- 
   2 - access("PS_PARTKEY"="L_PARTKEY" AND "PS_SUPPKEY"="L_SUPPKEY")
   3 - access("P_PARTKEY"="PS_PARTKEY")
       filter("PS_PARTKEY"=5 AND "P_TYPE"='MEDIUM ANODIZED BRASS' OR 
              "PS_PARTKEY"=5 AND "P_TYPE"='MEDIUM BRUSHED COPPER')
   4 - filter("PS_PARTKEY"=5)
\end{lstlisting}

Auf ps\_partkey wird gefiltert:
\begin{lstlisting}[style=sql]
CREATE INDEX ps_partkey_ix ON partsupps(ps_partkey);
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |               |     1 |    45 | 31055   (2)| 00:06:13 |
|   1 |  SORT AGGREGATE                |               |     1 |    45 |            |          |
|*  2 |   HASH JOIN                    |               |     4 |   180 | 31055   (2)| 00:06:13 |
|*  3 |    HASH JOIN                   |               |     4 |   144 |  1350  (23)| 00:00:17 |
|   4 |     TABLE ACCESS BY INDEX ROWID| PARTSUPPS     |     4 |    36 |     4   (0)| 00:00:01 |
|*  5 |      INDEX RANGE SCAN          | PS_PARTKEY_IX |     4 |       |     3   (0)| 00:00:01 |
|*  6 |     TABLE ACCESS FULL          | PARTS         |  2667 | 72009 |  1052   (1)| 00:00:13 |
|   7 |    TABLE ACCESS FULL           | LINEITEMS     |  6001K|    51M| 29675   (1)| 00:05:57 |
------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("PS_PARTKEY"="L_PARTKEY" AND "PS_SUPPKEY"="L_SUPPKEY")
   3 - access("P_PARTKEY"="PS_PARTKEY")
       filter("PS_PARTKEY"=5 AND "P_TYPE"='MEDIUM ANODIZED BRASS' OR "PS_PARTKEY"=5 AND 
              "P_TYPE"='MEDIUM BRUSHED COPPER')
\end{lstlisting}

Tabelle partsubs wird jetzt mit dem Index gescannt, Kosten von 35577 auf 31055 gesenkt. \\ 
Auf p\_type wird gefiltert:
\begin{lstlisting}[style=sql]
CREATE INDEX p_type_ix ON parts(p_type);
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
------------------------------------------------------------------------------------------------------
| Id  | Operation                            | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                     |               |     1 |    45 | 29885   (1)| 00:05:59 |
|   1 |  SORT AGGREGATE                      |               |     1 |    45 |            |          |
|*  2 |   HASH JOIN                          |               |     4 |   180 | 29885   (1)| 00:05:59 |
|   3 |    NESTED LOOPS                      |               |       |       |            |          |
|   4 |     NESTED LOOPS                     |               |     4 |   144 |   180   (0)| 00:00:03 |
|   5 |      TABLE ACCESS BY INDEX ROWID     | PARTSUPPS     |     4 |    36 |     4   (0)| 00:00:01 |
|*  6 |       INDEX RANGE SCAN               | PS_PARTKEY_IX |     4 |       |     3   (0)| 00:00:01 |
|   7 |      BITMAP CONVERSION TO ROWIDS     |               |       |       |            |          |
|   8 |       BITMAP AND                     |               |       |       |            |          |
|   9 |        BITMAP OR                     |               |       |       |            |          |
|  10 |         BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|* 11 |          INDEX RANGE SCAN            | P_TYPE_IX     |       |       |     8   (0)| 00:00:01 |
|  12 |         BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|* 13 |          INDEX RANGE SCAN            | P_TYPE_IX     |       |       |     8   (0)| 00:00:01 |
|  14 |        BITMAP OR                     |               |       |       |            |          |
|  15 |         BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|* 16 |          INDEX RANGE SCAN            | P_TYPE_IX     |       |       |     8   (0)| 00:00:01 |
|  17 |         BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|* 18 |          INDEX RANGE SCAN            | P_TYPE_IX     |       |       |     8   (0)| 00:00:01 |
|* 19 |     TABLE ACCESS BY INDEX ROWID      | PARTS         |     1 |    27 |   180   (0)| 00:00:03 |
|  20 |    TABLE ACCESS FULL                 | LINEITEMS     |  6001K|    51M| 29675   (1)| 00:05:57 |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("PS_PARTKEY"="L_PARTKEY" AND "PS_SUPPKEY"="L_SUPPKEY")
   6 - access("PS_PARTKEY"=5)
  11 - access("P_TYPE"='MEDIUM ANODIZED BRASS')
  13 - access("P_TYPE"='MEDIUM BRUSHED COPPER')
  16 - access("P_TYPE"='MEDIUM ANODIZED BRASS')
  18 - access("P_TYPE"='MEDIUM BRUSHED COPPER')
  19 - filter("P_PARTKEY"="PS_PARTKEY" AND ("PS_PARTKEY"=5 AND "P_TYPE"='MEDIUM ANODIZED 
\end{lstlisting}

Tabelle parts wird jetzt mit dem Index gescannt, Kosten von 31055 auf 29885 gesenkt. \\ 
Auf l\_partkey\_ix wird gejoined:
\begin{lstlisting}[style=sql]
CREATE INDEX l_partkey_ix ON lineitems(l_partkey);
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
-------------------------------------------------------------------------------------------------------
| Id  | Operation                             | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                      |               |     1 |    45 |   308   (0)| 00:00:04 |
|   1 |  SORT AGGREGATE                       |               |     1 |    45 |            |          |
|   2 |   NESTED LOOPS                        |               |       |       |            |          |
|   3 |    NESTED LOOPS                       |               |     4 |   180 |   308   (0)| 00:00:04 |
|   4 |     NESTED LOOPS                      |               |     4 |   144 |   180   (0)| 00:00:03 |
|   5 |      TABLE ACCESS BY INDEX ROWID      | PARTSUPPS     |     4 |    36 |     4   (0)| 00:00:01 |
|*  6 |       INDEX RANGE SCAN                | PS_PARTKEY_IX |     4 |       |     3   (0)| 00:00:01 |
|*  7 |      TABLE ACCESS BY INDEX ROWID      | PARTS         |     1 |    27 |   180   (0)| 00:00:03 |
|   8 |       BITMAP CONVERSION TO ROWIDS     |               |       |       |            |          |
|   9 |        BITMAP AND                     |               |       |       |            |          |
|  10 |         BITMAP OR                     |               |       |       |            |          |
|  11 |          BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|* 12 |           INDEX RANGE SCAN            | P_TYPE_IX     |       |       |     8   (0)| 00:00:01 |
|  13 |          BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|* 14 |           INDEX RANGE SCAN            | P_TYPE_IX     |       |       |     8   (0)| 00:00:01 |
|  15 |         BITMAP OR                     |               |       |       |            |          |
|  16 |          BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|* 17 |           INDEX RANGE SCAN            | P_TYPE_IX     |       |       |     8   (0)| 00:00:01 |
|  18 |          BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|* 19 |           INDEX RANGE SCAN            | P_TYPE_IX     |       |       |     8   (0)| 00:00:01 |
|* 20 |     INDEX RANGE SCAN                  | L_PARTKEY_IX  |    30 |       |     2   (0)| 00:00:01 |
|* 21 |    TABLE ACCESS BY INDEX ROWID        | LINEITEMS     |     1 |     9 |    32   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   6 - access("PS_PARTKEY"=5)
   7 - filter("P_PARTKEY"="PS_PARTKEY" AND ("PS_PARTKEY"=5 AND "P_TYPE"='MEDIUM ANODIZED 
              BRASS' OR "PS_PARTKEY"=5 AND "P_TYPE"='MEDIUM BRUSHED COPPER'))
  12 - access("P_TYPE"='MEDIUM ANODIZED BRASS')
  14 - access("P_TYPE"='MEDIUM BRUSHED COPPER')
  17 - access("P_TYPE"='MEDIUM ANODIZED BRASS')
  19 - access("P_TYPE"='MEDIUM BRUSHED COPPER')
  20 - access("PS_PARTKEY"="L_PARTKEY")
  21 - filter("PS_SUPPKEY"="L_SUPPKEY")
\end{lstlisting}

Tabelle lineitems wird jetzt mit dem Index gescannt, Kosten von 29885 auf 308 gesenkt. Die Kosten wurden im gesamten von 35577 auf 308 gesenkt (Faktor 115.5).

\section{Deep Left Join}
\begin{lstlisting}[style=sql]
SELECT *
FROM orders, lineitems, partsupps, parts
WHERE orders.o_orderkey = lineitems.l_orderkey
AND lineitems.l_suppkey = partsupps.ps_suppkey
AND partsupps.ps_partkey = parts.p_partkey;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
------------------------------------------------------------------------------------------
| Id  | Operation            | Name      | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |           |   482M|   229G|       |  9176K  (1)| 30:35:13 |
|*  1 |  HASH JOIN           |           |   482M|   229G|    27M|  9176K  (1)| 30:35:13 |
|   2 |   TABLE ACCESS FULL  | PARTS     |   200K|    25M|       |  1051   (1)| 00:00:13 |
|*  3 |   HASH JOIN          |           |   486M|   171G|   118M|   168K  (2)| 00:33:39 |
|   4 |    TABLE ACCESS FULL | PARTSUPPS |   800K|   109M|       |  4526   (1)| 00:00:55 |
|*  5 |    HASH JOIN         |           |  6086K|  1369M|   175M| 84027   (1)| 00:16:49 |
|   6 |     TABLE ACCESS FULL| ORDERS    |  1500K|   158M|       |  6610   (1)| 00:01:20 |
|   7 |     TABLE ACCESS FULL| LINEITEMS |  6001K|   715M|       | 29752   (1)| 00:05:58 |
------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("PARTSUPPS"."PS_PARTKEY"="PARTS"."P_PARTKEY")
   3 - access("LINEITEMS"."L_SUPPKEY"="PARTSUPPS"."PS_SUPPKEY")
   5 - access("ORDERS"."O_ORDERKEY"="LINEITEMS"."L_ORDERKEY")
\end{lstlisting}
\newpage
Nach einigem Suchen konnten wir anhand folgenden Statements einen Bushy Tree erzeugen:
\newline(Quelle: http://dboptimizer.com/2011/12/09/right-deep-left-deep-and-bushy-joins/ )
\begin{lstlisting}[style=sql]
SELECT  *
FROM 
(
SELECT /*+ no_merge */ *
FROM ORDERS, LIMEITEMS
WHERE ORDERS.o_orderkey = LINEITEMS.l_orderkey
)
,
(
SELECT /*+ no_merge */ *
FROM PARTSUPPS, PARTS
WHERE PARTSUPPS.ps_partkey = PARTS.p_partkey
)
WHERE l_suppkey = ps_suppkey;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
------------------------------------------------------------------------------------------
| Id  | Operation            | Name      | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |           |   482M|   286G|       |   211K  (2)| 00:42:23 |
|*  1 |  HASH JOIN           |           |   482M|   286G|   234M|   211K  (2)| 00:42:23 |
|   2 |   VIEW               |           |   792K|   225M|       | 12812   (1)| 00:02:34 |
|*  3 |    HASH JOIN         |           |   792K|   207M|    27M| 12812   (1)| 00:02:34 |
|   4 |     TABLE ACCESS FULL| PARTS     |   200K|    25M|       |  1051   (1)| 00:00:13 |
|   5 |     TABLE ACCESS FULL| PARTSUPPS |   800K|   109M|       |  4526   (1)| 00:00:55 |
|   6 |   VIEW               |           |  6086K|  1967M|       | 84027   (1)| 00:16:49 |
|*  7 |    HASH JOIN         |           |  6086K|  1369M|   175M| 84027   (1)| 00:16:49 |
|   8 |     TABLE ACCESS FULL| ORDERS    |  1500K|   158M|       |  6610   (1)| 00:01:20 |
|   9 |     TABLE ACCESS FULL| LINEITEMS |  6001K|   715M|       | 29752   (1)| 00:05:58 |
------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("L_SUPPKEY"="PS_SUPPKEY")
   3 - access("PARTSUPPS"."PS_PARTKEY"="PARTS"."P_PARTKEY")
   7 - access("ORDERS"."O_ORDERKEY"="LINEITEMS"."L_ORDERKEY")
\end{lstlisting}
\textbf{Reflexion} \newline
Beim Vergleichen der beiden Ausführungspläne erkennt man schnell, dass die erste Version eines Deep Left Joins sehr hohe Kosten mit sich bringt. Diese werden v.A. durch das mehrmalige Joinen derselben Tabellen verursacht.\newline
Im zweiten Statement wird durch das Verwenden von Hints eine Reihenfolge erzwingt, in der die Tabellen gejoined werden sollen und das Mergen wird unterbunden.\newline
Durch den Ausführungsplan sieht man schnell, dass so ein Bushy Tree erstellt wird. Ausserdem merkt man, dass die Kosten um ein Vielfaches geringer sind als beim ersten Statement. (Um den Faktor 43)\newline
\newline
Um die Anfrage weiter zu Beschleunigen haben wir folgende Indizes erstellt:
\begin{lstlisting}[style=sql]
CREATE INDEX o_orderkey_ix ON orders(o_orderkey);
\end{lstlisting}
\begin{lstlisting}[style=sql]
CREATE INDEX l_orderkey_ix ON lineitems(l_orderkey);
\end{lstlisting}
\begin{lstlisting}[style=sql]
CREATE INDEX l_suppkey_ix ON lineitems(l_suppkey);
\end{lstlisting}
\begin{lstlisting}[style=sql]
CREATE INDEX ps_suppkey_ix ON partsupps(ps_suppkey);
\end{lstlisting}
\begin{lstlisting}[style=sql]
CREATE INDEX ps_partkey_ix ON partsupps(ps_partkey);
\end{lstlisting}
\begin{lstlisting}[style=sql]
CREATE INDEX p_partkey_ix ON parts(p_partkey);
\end{lstlisting}
Deep Left Join:
\begin{lstlisting}[style=queryexecutionplan]
------------------------------------------------------------------------------------------
| Id  | Operation            | Name      | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |           |   482M|   229G|       |  9176K  (1)| 30:35:13 |
|*  1 |  HASH JOIN           |           |   482M|   229G|    27M|  9176K  (1)| 30:35:13 |
|   2 |   TABLE ACCESS FULL  | PARTS     |   200K|    25M|       |  1051   (1)| 00:00:13 |
|*  3 |   HASH JOIN          |           |   486M|   171G|   118M|   168K  (2)| 00:33:39 |
|   4 |    TABLE ACCESS FULL | PARTSUPPS |   800K|   109M|       |  4526   (1)| 00:00:55 |
|*  5 |    HASH JOIN         |           |  6086K|  1369M|   175M| 84027   (1)| 00:16:49 |
|   6 |     TABLE ACCESS FULL| ORDERS    |  1500K|   158M|       |  6610   (1)| 00:01:20 |
|   7 |     TABLE ACCESS FULL| LINEITEMS |  6001K|   715M|       | 29752   (1)| 00:05:58 |
------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("PARTSUPPS"."PS_PARTKEY"="PARTS"."P_PARTKEY")
   3 - access("LINEITEMS"."L_SUPPKEY"="PARTSUPPS"."PS_SUPPKEY")
   5 - access("ORDERS"."O_ORDERKEY"="LINEITEMS"."L_ORDERKEY")
\end{lstlisting}

Bushy Tree:
\begin{lstlisting}[style=queryexecutionplan]
------------------------------------------------------------------------------------------
| Id  | Operation            | Name      | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |           |   482M|   286G|       |   211K  (2)| 00:42:23 |
|*  1 |  HASH JOIN           |           |   482M|   286G|   234M|   211K  (2)| 00:42:23 |
|   2 |   VIEW               |           |   792K|   225M|       | 12812   (1)| 00:02:34 |
|*  3 |    HASH JOIN         |           |   792K|   207M|    27M| 12812   (1)| 00:02:34 |
|   4 |     TABLE ACCESS FULL| PARTS     |   200K|    25M|       |  1051   (1)| 00:00:13 |
|   5 |     TABLE ACCESS FULL| PARTSUPPS |   800K|   109M|       |  4526   (1)| 00:00:55 |
|   6 |   VIEW               |           |  6086K|  1967M|       | 84027   (1)| 00:16:49 |
|*  7 |    HASH JOIN         |           |  6086K|  1369M|   175M| 84027   (1)| 00:16:49 |
|   8 |     TABLE ACCESS FULL| ORDERS    |  1500K|   158M|       |  6610   (1)| 00:01:20 |
|   9 |     TABLE ACCESS FULL| LINEITEMS |  6001K|   715M|       | 29752   (1)| 00:05:58 |
------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("L_SUPPKEY"="PS_SUPPKEY")
   3 - access("PARTSUPPS"."PS_PARTKEY"="PARTS"."P_PARTKEY")
   7 - access("ORDERS"."O_ORDERKEY"="LINEITEMS"."L_ORDERKEY")
\end{lstlisting}
\textbf{Reflexion} \newline
Wir haben festgestellt, dass der Oracle Optimizer die Verwendung von Indizes sowohl beim Bushy Tree, als auch beim Left Deep Join unterbunden hat, weswegen die Performance nicht weiter verbessert werden konnte.

\section{Eigene SQL-Abfragen}
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM lineitems, orders
WHERE l_orderkey=o_orderkey
AND o_orderkey BETWEEN 100 AND  1000;
\end{lstlisting}
Ergibt ohne Index folgenden Aufsführungsplan:
\begin{lstlisting}[style=queryexecutionplan]
--------------------------------------------------------------------------------
| Id  | Operation          | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |           |   227 | 53572 | 36282   (1)| 00:07:16 |
|*  1 |  HASH JOIN         |           |   227 | 53572 | 36282   (1)| 00:07:16 |
|*  2 |   TABLE ACCESS FULL| ORDERS    |   227 | 25197 |  6602   (1)| 00:01:20 |
|*  3 |   TABLE ACCESS FULL| LINEITEMS |   908 |   110K| 29679   (1)| 00:05:57 |
--------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - access("L_ORDERKEY"="O_ORDERKEY")
   2 - filter("O_ORDERKEY"<=1000 AND "O_ORDERKEY">=100)
   3 - filter("L_ORDERKEY"<=1000 AND "L_ORDERKEY">=100)
\end{lstlisting}

Nun setzten wir je einen Index auf o\_orderkey und l\_orderkey.

\begin{lstlisting}[style=sql]
CREATE INDEX l_orderkey_ix ON lineitems(l_orderkey);
CREATE INDEX o_orderkey_ix ON orders(o_orderkey);
\end{lstlisting}

\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------------------------
| Id  | Operation                    | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |               |   227 | 53572 |    51   (2)| 00:00:01 |
|*  1 |  HASH JOIN                   |               |   227 | 53572 |    51   (2)| 00:00:01 |
|   2 |   TABLE ACCESS BY INDEX ROWID| ORDERS        |   227 | 25197 |    11   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN          | O_ORDERKEY_IX |   227 |       |     3   (0)| 00:00:01 |
|   4 |   TABLE ACCESS BY INDEX ROWID| LINEITEMS     |   908 |   110K|    39   (0)| 00:00:01 |
|*  5 |    INDEX RANGE SCAN          | L_ORDERKEY_IX |   908 |       |     5   (0)| 00:00:01 |
----------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - access("L_ORDERKEY"="O_ORDERKEY")
   3 - access("O_ORDERKEY">=100 AND "O_ORDERKEY"<=1000)
   5 - access("L_ORDERKEY">=100 AND "L_ORDERKEY"<=1000)
\end{lstlisting}

Durch Verwendung der Indexes konnten die Kost von 36282 auf 51 gesenkt weden (Faktor 711).

% Inhalt Ende
\end{document} 
